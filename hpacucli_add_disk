#!/usr/bin/env python3

# Imports ######################################################################

import json
import os
import stat
import sys
import re
import subprocess
import  shutil
import argparse
import socket
import pwd
import grp
import time
import datetime
import sys

class Scality():
    '''
    '''

    def __init__(self, args):

        # Vars ################################################################

       self.logical = []
       self.physical = []
       self.lv_nb = 0
       self.pd_nb = 0
       self.ctrl_nb = 0
       self.scalitydisk = None
       self.mount_point = None
       self.replace = None
       self.wipe = None
       self.lock_file = None
       self.disk_uuid_old = None
       self.get_device = False
       self.hpacucli = None
       self.slot = None
       self.ld = None
       self.pd = None
       self.lock_file = None
       self.fstype = 'ext4'
       self.smart = []
       self.logical = []
       self.physical = []
       self.RED   = "\033[1;31m"
       self.BLUE  = "\033[1;34m"
       self.CYAN  = "\033[1;36m"
       self.GREEN = "\033[0;32m"

       #Terminology  ##########################################################
       '''
       :self.device = disk /dev/sdxx
       :self.slot = used slot : slotx
       :self.ld = logicaldrive : ldxx
       :self.pd = physicaldrive : pdxx
       :self.scaldisk = scality disk : diskxx
       :self.disk_uuid_old = Uuid of disk before changing it
       :self.disk_uuid = UId of disk after changing it
       :self.mount_p = mount point : /mnt/diskxx
       '''
       # Check if storcli binary exist and cluster is health ##################
       self.manufacturer = subprocess.getoutput('dmidecode -s system-manufacturer')
       self.hpacucli_binary = self.find_program_binary("hpacucli")
       self.ssacli_binary = self.find_program_binary("ssacli")
       self.changedisk_binary = self.find_program_binary("change-disk.sh")
       self.biziod_binary = self.find_program_binary("scality-iod")
       if not "HP" in self.manufacturer.upper():
           self.error_exit("Error : This script is only supported by <HP> servers")
       if not self.hpacucli_binary:
           if not self.ssacli_binary:
               self.error_exit("Error : C'ant found <hpacucli> or/and <ssacli> binary")
       if not self.changedisk_binary:
           self.error_exit("Error : C'ant found <change-disk.sh> binary")
       if not self.biziod_binary:
           self.error_exit("Error : C'ant found <scality-iod> binary")

        # Args #################################################################
       if args.wipe:#--wipe to wipe disk
           self.wipe = args.wipe
       if args.replace:#--replace to replace disk
           self.replace = args.replace
       if args.device:
           self.device = args.device#--device name : sdxx
       if args.scaldisk:
           self.scaldisk = args.scaldisk#--scaldisk name : diskxx
       if args.physicaldrive :
           self.physicaldrive = args.physicaldrive#--physicaldrive : pdisk

        # Set vars if --replace + --scaldisk + --logicaldrive  #################
       '''
        this option is usable when the script can not detect the mounted disk
        with this option we force the pdisk we will replace as well as the scality mount point
       '''
       if args.replace and args.scaldisk and args.physicaldrive:
          self.pd = self.physicaldrive
          self.slot, self.ld = self.find_disk('/dev/sdxx' , 'physical')
          self.device = self.disk_management(self.slot, self.ld, self.pd)
          self.mount_p = self.found_mount_p(self.device)
          self.disk_uuid_old = self.find_uuid_unknow_device(self.scalitydisk)

        # Set vars if --wipe + --device  #######################################
       '''
        this option is usable when one wants to replace or to format a disk
        the only argument to give: it is the device: /dev/sdxx
       '''
       if (args.wipe or args.replace) and args.device:
          if "/dev/" in self.device:
              stat.S_ISBLK(os.stat(self.device).st_mode)
          else:
              stat.S_ISBLK(os.stat("/dev/" + self.device).st_mode)
              self.device = "/dev/{}".format(self.device)
          self.slot, self.ld, self.pd = self.find_pd(self.device, "logical")
          if self.slot and self.ld and self.pd :
              self.check_pd_ld_status(self.slot, self.ld, self.pd)
          else:
              error_exit('Error : Cant found all information about disk  : LD , SLOT, PD')
          self.mount_p = self.found_mount_p(self.device)
          self.mount_point = str(re.findall(r'\d+', self.mount_p))[1:-1]
          self.mount_point = self.mount_point.lstrip('\"')
          self.scalitydisk = self.mount_point.replace("'", "")
          self.disk_uuid_old = self.get_uuid(self.device)

       # Set vars if --oio + --wipe  ################################################################
       #find the disk against the oiodisk given
       '''
       this option is usable when one wants to place or to format a disk
       the only argument to give: it is the scalitydisk: diskxx:
       '''
       if (args.wipe or args.replace) and args.scaldisk:
           if "disk" in self.scaldisk:
               self.scaldisk = self.scaldisk.split("disk")
           self.scalitydisk = self.scaldisk
           self.get_device = True
           self.device = self.found_mount_p(self.get_device)
           with open("/etc/fstab") as fstab:
                for line in fstab:
                    if "disk{}".format(self.scalitydisk) in line:
                        uuid = (line.split("UUID=")[1]).split(" ")[0]
                        self.dev = subprocess.getoutput("blkid |grep \"{}\" |awk \'{{print $1}}\' |cut -d\':\' -f1".format(uuid))
                        if not self.device:
                            self.device = self.dev
                        else:
                            if self.device != self.dev:
                                self.error_exit('Error : Wrong mount option')
                        if not self.device:
                            self.error_exit('Error : cant found disk mounted on disk{} with uuid :[{}]\n maybe the disk is HS : must change it'.format(self.scaldisk, uuid))
           if self.device:
               self.get_device = False
               self.mount_p = self.found_mount_p(self.device)
               self.disk_uuid_old = self.get_uuid(self.device)
               self.slot, self.ld, self.pd = self.find_pd(self.device, "logical")
               if self.slot and self.ld and self.pd :
                  self.check_pd_ld_status(self.slot, self.ld, self.pd)

       if not self.device or not self.scalitydisk:
           self.error_exit('Error : cant determinate device or/and scalitydisk')

       #enable locking and dislocking disk to prevent multiple wipe and/or replacing disk####
       '''
       if lock file exist : we check it created time :
       if > 360s : we delete lock, else, we stop wipe or replace processing
       '''
       self.lock_file = '/var/run/scality/disk-{}'.format(self.scalitydisk)
       if  os.path.isfile(self.lock_file):
           if  time.time() - os.path.getmtime(self.lock_file) > 360:
               self.printing_message('Info', '[Scality] cleaning lock of disk{}'.format(self.scalitydisk))
               os.remove(self.lock_file)
               os.mknod(self.lock_file)
           else:
               self.error_exit('Error: disk locked by another wiping or/and replacing process\n {}'.format(self.lock_file))
       else:
           os.mknod(self.lock_file)

       # Common tasks ####################################################
       '''
       User validation of wipe or replace information
       Stop biziod service on given disk
       wipe disks
       start biziod service
       reload bizobj on disk
       '''
       self.validation(self.slot, self.ld, self.pd, self.scalitydisk, self.device, self.disk_uuid_old)
       self.stop_start_biziod(self.scalitydisk, "stop", self.device, self.mount_p)
       self.wipe_disk(self.fstype, self.device, self.scalitydisk, self.disk_uuid_old, self.mount_p)
       self.stop_start_biziod(self.scalitydisk, "start", self.device, self.mount_p)
       self.printing_message("Info", "[Scality] : Reload bizobj on disk{}".format(self.scalitydisk))
       self.rc = subprocess.call(["/usr/local/bin/change-disk.sh", "--reload", "disk{}".format(self.scalitydisk)])
       if self.rc != 0:
           self.error_exit("Error : Cannot reload bizobj on disk{}".format(self.scalitydisk))
       else:
           with open('/etc/scality-rings.conf', 'r') as content_file:
               content = content_file.read()
           if not os.path.isdir(self.mount_p):
               self.error_exit("Error : Cannot write on disk{}".format(self.scalitydisk))
           else:
               self.printing_message("Ok", "[Scality] : DONE! finishing working on disk{}".format(self.scalitydisk))
               sys.exit(0)

    def error_exit(self,message):
        '''
        Exit(3) when error detected
        '''
        print(self.RED + message)
        sys.exit(3)

    def printing_message(self, severity, msg):
        '''
        Format printed messages
        '''
        if severity == "Info":
            color = self.BLUE
        elif severity == "Notification":
            color = self.CYAN
        elif severity == "Error":
            color = self.RED
        elif severity == "Ok":
            color = self.GREEN
        else:
            self.error_exit("Uknown color")
        print(color + msg)

    def find_program_binary(self, program):
        '''
        find path of given find_program
        '''
        path=os.getenv('PATH')
        for p in path.split(os.path.pathsep):
            p=os.path.join(p,program)
            if os.path.exists(p) and os.access(p,os.X_OK):
                return(p)

    def disk_management(self, slot, ld, pd):
        '''
        used when we use --replace option:
        - enable led on faulty disk
        - disable led
        - detect new disk
        '''
        self.printing_message("Notification", "[Storcli] Enable LED on faulty disk : {}".format(pd))
        led_enabling_rc = subprocess.call('hpacucli ctrl slot={} pd {} modify led=on'.format(slot, pd), shell=True)
        if led_enabling_rc !=0:
            self.error_exit('Error : Cannot Enable LED on {}'.format(pd))
        self.user_choice('hpacucli ctrl slot={} pd {} modify led=on'.format(slot, pd), 'Scality : tape <yes> when you want to disable LED on {}'.format(pd))
        retries = 0
        while True:
            retries += 1
            self.printing_message('Info', 'Waiting to detect the replaced disk : {}s(Max 300s)'.format(retries))
            check_status = subprocess.getoutput("hpacucli  ctrl slot={} pd {} show".format(slot, pd))
            if "unassigned" in check_status:
                success = True
                break
            if retries > 300:
                self.error_exit("Error", "The disk {} was not changed or not detected after replace\n {}".format(pd, check_status))
        disk_list = self.disks_list()
        self.printing_message("Notification", "[Scality] Create the corresponding RAID0 : {}".format(pd))
        raid_rc = subprocess.call('hpssacli controller slot={} create type=logicaldrive drives={} raid=0'.format(slot, pd), shell=True)
        if raid_rc != 0:
            self.error_exit("Error when creating RAID0")
        p_disk = self.detect_new_disk(disk_list)
        return(disk)

    def disks_list(self):
        '''
        Get name of new disk
        '''
        disks = []
        list_disk = subprocess.getoutput("blkid |awk \'{{ print $1 }}\'")
        list_disk = list_disk.split()
        for line in list_disk:
            disks.append(line.split(":")[0])
        return(disks)

    def detect_new_disk(self, disk_list):
            '''
            compare new disk list and disk list before changing disk to detect the new one
            '''
            new_disk_list = self.disks_list()
            old_disk_list = disk_list
            new_disk = [item for item in new_disk_list if item not in old_disk_list]
            if len(new_disk) > 1:
                error_exit(self.RED + "More than 1 disk was detected")
            else:
                return(new_disk)

    def stop_start_biziod(self, disk, action, device, mnt_p):
        disk_status = subprocess.getoutput('scality-iod status disk{}'.format(disk))
        if action == "stop":
            if "not running" in disk_status:
                self.printing_message("Info", "[Scality] : biziod process was already stopped on disk{}".format(disk))
            else:
                self.printing_message("Info", "[Scality] : Stop biziod process  on  disk{}".format(disk))
                disk_status = subprocess.getoutput('scality-iod {} disk{}'.format(action, disk))
                if not "done" in disk_status:
                    self.error_exit("Error : Failed to stop biziod process on disk{}\n{}".format(disk, disk_status))
                else:
                     umount_output = subprocess.getoutput("umount -l {}".format(mnt_p))
                     check_mount = subprocess.getoutput("mount |grep  \"{}\"".format(device))
                     if check_mount:
                         self.error_exit("Error : Failed to umount {}".format(mnt_p))
        elif action == "start":
            disk_status = subprocess.getoutput('scality-iod status disk{}'.format(disk))
            if "not running" in disk_status:
                 self.printing_message("Info", "[Scality] : {} biziod process on disk{}".format(action, disk))
                 disk_status = subprocess.getoutput('scality-iod {} disk{}'.format(action, disk))
                 check_mount = subprocess.getoutput("mount |grep  \"{}\"".format(device))
                 if not check_mount:
                     self.error_exit("Error : Failed to mount {} on {}".format(device, mnt_p))
            else:
                self.printing_message("Info", "[Scality] : biziod process was already started on disk{}".format(disk))
        else:
            self.error_exit("Error : Action {} not supported".format(action))

    def wipe_disk(self, fstype, device, scaldisk, uuid, mnt_p):
        if self.fstype == 'ext4':
            wipe_cmd = "mkfs.{} -F {} ".format(fstype, device)
        else:
            error_exit(self.RED + "This script support only {} FS".format(self.fstype))
        self.printing_message("Info", "[Scality] : Wiping {} using {}".format(device, fstype))
        check_mount = subprocess.getoutput("mount |grep {}".format(device))
        if check_mount:
             error_exit("Error : Failed to umount {}".format(mnt_p))
        else:
            wipe_check = subprocess.getoutput(wipe_cmd)
            if self.get_uuid(self.device) == uuid:
                self.error_exit("Err : Failed to wipe disk\n" + wipe_check)
            self.cmd_execute("sed -i s/{}/{}/g {}".format(uuid, self.get_uuid(self.device), '/etc/fstab'))

    def cmd_execute(self, command):
        '''
        Execute command and handle erros
        '''
        try:
            cmd = subprocess.Popen(command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
            result = cmd.stdout.readlines()
            print(self.GREEN + "[Success]")
            return(result)
        except subprocess.CalledProcessError as exc:
            print(self.RED + "Status : FAIL", exc.returncode, exc.cmd)


    def validation(self, slot, ld, pd, scalitydisk, device, uuid):
        '''
        Validation process before wiping disk
        '''
        elements = []
        n = locals()
        check_elements = ("slot", "ld", "pd", "scalitydisk", "device", "uuid")
        for element in check_elements:
            if n[element]:
                elements.append(element + " : " + str(n[element]) + " : [OK]")
            else:
                elements.append(element + " " + str(n[element]) + " : [ERR]")
        if len(elements) > 0:
            print(elements)
            if any("Err" in s for s in elements):
                self.error_exit("Error : failed to fetch one or/and many information")
            else:
                self.user_choice("test", "Check information : if evrything is OK : tape <yes>")

    def user_choice(self, cmd, msg):
        '''
        storcli start location on failed disk
        '''
        reply = ["yes"]
        user_choice = None
        while user_choice  not in reply:
            user_choice = input(self.GREEN + msg + "\n")
        self.cmd_execute(cmd)

    def check_pd_ld_status(self, slot, ld, pd):
        status = subprocess.getoutput('hpacucli ctrl slot={} ld {} show detail'.format(slot, ld))
        r1 = (re.findall("Status:.*", status))
        if not "OK" in str(r1):
            self.error_exit('Error : Failed LD {} on slot {}\n {}'.format(ld, slot, status))
        status = subprocess.getoutput('hpacucli ctrl slot={} pd {} show detail'.format(slot, pd))
        r1 = (re.findall("Status:.*", status))
        if not "OK" in str(r1):
            self.error_exit('Error : Failed LD {} on slot {}\n {}'.format(pd, slot, status))

    def list_pd_ld(self, tuple):
        self.hpacucli = tuple
        for element in self.hpacucli:
            logical = re.compile('^.*logicaldrive.*$')
            physical = re.compile('^.*physicaldrive.*$')
            smart = re.compile('^Smart Array .*$')
            if (logical.match(element)):
                # Add the next logical drive to the previous array dict
                self.lv_nb += 1
                self.logical.append(element)
                # Insert all controllers in dedicated list of dict
            if (smart.match(element)):
                self.ctrl_nb += 1
                self.smart.append(element)
               # Insert all physicaldrives in dedicated list of dict
            if (physical.match(element)):
             # Add the next physical drive to the previous logical drive dict
                self.pd_nb += 1
                self.physical.append(element)
        return(self.logical, self.physical, self.ctrl_nb)

    def find_uuid_unknow_device(self, scalitydisk):
        with open('/etc/fstab') as fstab:
            for line in fstab:
                if scalitydisk in line:
                    uuid = line.split(" ")[0]
                    uuid = uuid.split('UUID=')
                    return(''.join(uuid))

    def hpacucli_output(self):
        hpacucli = subprocess.Popen(['sudo', 'hpacucli', 'ctrl', 'all', 'show', 'config'], stdout=subprocess.PIPE)
        res = hpacucli.communicate()[0]
        output = []
        for r in res.decode('utf-8').splitlines():
            r = r.lstrip()
            if (r != ''):
                output.append(r)
        if output:
            return(output)

    def find_disk(self, device, component):
        self.printing_message("Info", "[HP] Start Slot, LD and PD identification : {}".format(device))
        output = self.hpacucli_output()
        ld, pd, ctrl = self.list_pd_ld(output)
        ctrl = ctrl + 1
        if component == "logical":
            naa = self.find_naa(device)
            self.printing_message("Notification", '[HP] Scan devices to find Slot and LD used by  [{}]:'.format(device))
            for element in ld:
                id_logical = element.split(" ")[1]
                for slot in range(0, ctrl):
                    print(self.CYAN ,'Scan : Slot:[{}] : LD:[{}]'.format(slot, id_logical),  end="\r")
                    detail_ld = subprocess.getoutput("hpacucli ctrl slot={} ld {} show detail".format(slot, id_logical))
                    if not naa:
                        if device in detail_ld:
                             logical_drive = id_logical
                             self.printing_message("Notification", "[HP] Disk [{}] is located on : slot=[{}] and LD: [{}]".format(device, slot, logical_drive))
                             return(slot, logical_drive)
                    else:
                         naa = naa.upper()
                         if naa in detail_ld:
                             logical_drive = id_logical
                             self.printing_message("Info", "[HP] Disk [{}] is located on : slot=[{}] and LD: [{}]".format(device, slot, logical_drive))
                             return(slot, logical_drive)
        if component =="physical":
            pd = self.pd
            for slot in range (0, ctrl):
                print(self.CYAN ,'Scan : Slot:[{}] : PD:[{}]'.format(slot, pd),  end="\r")
                detail_pd = subprocess.getoutput("hpacucli ctrl slot={} pd {} show detail".format(slot, pd))
                if pd in detail_pd:
                    array = subprocess.getoutput('hpacucli ctrl slot={}  pd {} show detail |grep array |awk \'{{ print $2}}\''.format(slot, pd))
                    ld = subprocess.getoutput('hpacucli ctrl slot={} ld all show |grep -A2 \"array {}\"  |grep logicaldrive |awk \'{{ print $2 }}\''.format(slot, array))
                    self.printing_message("Notification", "[HP] Slot [{}] : LD=[{}] and PD: [{}]".format(slot, ld, pd))
                    return(slot, ld)

    def find_pd(self, device, component):
        slot, ld = self.find_disk(device, component)
        array = subprocess.getoutput("hpacucli ctrl slot={} ld {} show | awk '/array/'".format(slot, ld))
        if array:
            array = subprocess.getoutput('hpacucli ctrl slot={} pd all show | egrep -A2 \'{}\' |egrep -v array'.format(slot, array)).strip()
            pd = array.split(" ")[1]
            return(slot, ld, pd)

    def find_naa(self, device):
        '''
        Send iscsi inquiry to get NAA
        '''
        naa_regex = re.compile('0x([0-9a-z]{32})')

        sg_inq_check = subprocess.getstatusoutput('sg_inq')
        if sg_inq_check[0] not in (0, 1):
            sys.stderr.write('sg_inq (package sg3-utils) doesn\'t seem to be installed.\n')
            sys.exit(1)

        cmd = 'sg_inq -p 0x83 {}'.format(device)
        output = subprocess.getoutput(cmd)
        match = naa_regex.search(output)
        return match.group().replace('0x', '')

    def get_uuid(self, device):
        '''
        Get uuid of given /dev/disk
        '''
        cmd = 'blkid {} | awk \'{{ print $2 }}\' |cut -d ""="" -f2 |sed \'s/^"\(.*\)".*/\\1/\''.format(device)
        Disk_uuid = subprocess.getoutput(cmd)
        return(Disk_uuid)

    def found_mount_p(self, device):
        '''
        Find out the mount point from given /dev/disk
        '''
        cmd = "df -h | grep {}".format(device)
        mount_point = subprocess.getoutput(cmd).split(" ")[-1]
        if not mount_point:
            Disk_uuid = self.get_uuid(device)
            if Disk_uuid or (mount_point and self.get_device):
                with open("/etc/fstab") as fstab:
                    for line in fstab:
                        if Disk_uuid in line:
                             if self.get_device:
                                 mount_point = line.split(" ")[0]
                             else:
                                 mount_point = line.split(" ")[1]
        return(mount_point)

def main():
    parser = argparse.ArgumentParser(
        description='Output storcli and smartctl for a failed device',
        add_help=True
    )
    parser.add_argument('--device', type=str,
                        help='device to scan')
    parser.add_argument('--wipe', action='store_true',
                        help='wipe disk and put it back in cluster')
    parser.add_argument('--replace', action='store_true',
                        help='Change the defective disk:\
                            --replace --device /dev/sdxx')
    parser.add_argument('--scaldisk', type=str,
                        help='wipe disk and put it back in cluster')
    parser.add_argument('--physicaldrive', type=str,
                        help='physicaldrive')
    args = parser.parse_args()

    if args.replace or args.wipe:
        if not args.device and not args.scaldisk:
            sys.stderr.write('--replace and --wipe options must be used with --device or --scaldisk.\n')
            sys.exit(1)

    if  args.device or args.scaldisk:
        if not args.replace and not args.wipe:
            sys.stderr.write('--device and --oio options  must be used with --replace or --wipe option.\n')
            sys.exit(1)

    if  args.physicaldrive:
        if not args.replace and not args.scaldisk:
            sys.stderr.write('--physicaldrive options must be used with --replace or --scaldisk option.\n')
            sys.exit(1)

    scality = Scality(args)
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('Interrupted')
        try:
            sys.exit(0)
        except SystemExit:
            sys.exit(0)
